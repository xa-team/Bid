지금 채팅 끝. 경매 만들어야함. 포인트 input number로 만들었음. 채팅쳤을때 최소 5포인트 이상 더해진 숫자가 value값으로 들어왔으면 좋겠음

지금 이제 카운트다운, 잔여 포인트, 내가 입찰 넣었을때는 입찰 불가능, +5 +10 +20 +100 버튼 만들어야함




7/13
경매버튼 다 만듦. 알림 가운데 정렬해야됨.

잔여 포인트 및 카운트다운 타이머 만들어야함

채팅 및 알림 정렬 완료

스크롤 아래 고정시키는거 해야됨


7/13 밤

가운데 정렬 다 완료
프로필 사진 만듦
프로필 사진 및 채팅 옆에 놓고 좌 정렬

내가 보낸거 우 정렬 성공

flexbox 속성 공부
scrollbar 공부

maring padding 순서 공부

Img 객체 쓰는법

let과 Var의 차이점

display inline block?


그리고 버튼 디자인


해야될것 : 잔여 포인트, 타이머, A유저와 B유저 입찰 PRICE 동일하게 만들기


7/14

A유저와 B유저 입찰 PRICE 동일하게 만들기 : Clear

코드 정리, 변수 선언 내용 파트별로 묶어 놓기. 헷갈리지 않도록


중복코드 함수로 정리하기



div , span, p 차이 : div, span은 블록요소, p는 inline요소이다. div는 주로 레이아웃 계층 나누기 용도
p는 문자 단략 용도임.


오늘 한 것: 잔여 포인트 표시, 공통된 코드 함수로 정리, 현재 입찰가 서버에서 관리하도록, Flex 속성에대해 공부
그리고 적용. 채팅 엔터로 쳐지게끔. input 크기를 작게 만들고 싶으면 min-width: 0 해놓기
잔여 포인트 부족할 시 오퍼 못넣게끔


해야할 것 : 잔여포인트 실시간으로 표시 되게끔.(이때 클라별로 잔여포인트 따로 제대로 뜨는지 확인하기
 - 소켓 이벤트 타입 객체로 정리하기 
 - 타이머 만들기
 - 비드 넣을때마다 타이머 초기화
 - 타이머 끝나면 낙찰 알림 및 잔여 포인트 깎기, bidPrice 초기화
 - 도배 방지 생각해보기

 7/15

 - 소켓 이벤트 타입 객체로 정리하기 : O
 - 타이머 만들기
 - 비드 넣을때마다 타이머 초기화
 - 타이머 끝나면 낙찰 알림 및 잔여 포인트 깎기, bidPrice 초기화
 - 도배 방지 생각해보기
 - 개발의 5대원리 SOLID
 - 의존성 역전 원칙
 
요즘 개발 트렌드 변수 거의 안씀. 자잘한건 const로 씀 => 지금부터는 웬만하면 let, var 안쓰기


7/16
 - 타이머 끝나면 낙찰 알림 및 잔여 포인트 깎기, bidPrice 초기화
   => 기반 만들어 놓음. 타이머는 server에서 돌리고, offer 이벤트 발생시 타이머 15초로 초기화
   타이머 끝날시(SuccessBid 이벤트) io.sockets.emit으로 모든 사람에게 bidder 날림. 같을 경우 잔여포인트 차감.
   그리고 **: OOO포인트 - 낙찰 뜨게끔 바꿈. 낙찰 글씨는 파스텔톤 빨강으로 해놓음
   
   이때 attribute 함수를 사용


 - 변수명 조금 더 명확하게 바꿈
 - 입찰했을때 낙찰된 사람 이름 bidder로
 - bidPrice -> currentBid
 - offerBtn 바꿈 누르면 아래 input 숫자가 바뀌도록
 

7/18
 - 타이머 만들어놓음. 그리고 낙찰시 공지 및 낙찰 메시지 뜸
 - attribute 함수를 colormessage.style.color 로 바꿈 이게 맞음


7/24
 - 낙찰시 잔여포인트 줄어들게 => socket.name을 이용해 사용자를 구별
 - 다음 경매로 넘어갈때 메시지 한번 클리어 => document.querySelectorAll()을 이용
 - 낙찰시 현재 경매 금액 0으로 만들기 ==> 현재 경매되고 있는 금액 : currentBid, 낙찰된 금액: winningBid로 구분



...args : 나머지인자, 가변인자
 => 이거 굉장히 친절함. 함수에서 받는 인자의 개수를 모를때 쓰는 인자. 
    쓰게되면 배열 형태로 들어옴. 즉 argument라는것
array 는 배열
argument는 배열 형태의 객체

hoisting : 화살표 함수 쓸때 알아야할 개념
 => 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것
 => hoisting의 대상: var 변수 선언과 함수 선언문, let과 const 변수 선언, 함수 표현식에서는 호이스팅이 발생하지 않음.


IIFE (Immediately Invoked Function Expression) : 화살표 함수의 응용
()로 감싸서 함수의 명칭없이 바로 실행하는 것이 특징

ex)

(() => {
  // …
})();

(async () => {
  // …
})();


